---
title: "[개발로그]2018-11-12(월)"
layout: post
date: 2018-11-12 21:20
image: /assets/images/markdown.jpg
headerImage: false
star: true
category: blog
author: woogie
---



# Today Log

오늘은 구현한 프로젝트 리팩토링을 진행함.



### 수정사항

1. 클래스네임룰 _에서 -방식으로 수정

2. 자주쓰는 변수명 축약해서 표현 예를 들면 elements ==> _e

3. 렌더링을 여러번 하는 것은 안좋다는 것을 느꼈다



   ~~~js
   this.render(firstView);
   this.render(this.contentData);
   this.render(firstView);
   ~~~

   이렇게 렌더함수를 세번 호출하는 것 보다

   ~~~js
   this.render(this.getInitRenderData);
   ~~~

   이렇게 렌더할 데이터를 concat으로 합쳐주고 한번만 렌더해주는 게 더 좋다.



### 리팩토링

1. resetToInitContent메서드

   ~~~js
   resetToInitConttent(initPositionX){
       setTimeout(()=>{
               this.slideListEl.style.transition = "";
               this.currentPositionX = initPositionX;
               this.slideListEl.style.transform =`translateX(${this.currentPositionX}%)`;
       },this.timer);
   }
   ~~~

   이 코드는 애니메이션효과가 0.5초라면 0.5초후에 x좌표를 초기화해주는 역할의 메서드였는데, 

   새롭게 transitionend라는 기능을 알게 됐다. 사용법은 이렇다.

   ~~~js
   element.addEventListener('transitionend', updateTransition, true)
   
   //updateTransition가 콜백함수인데, 이 함수에 자신이 주고싶은 동작을 주면 된다.
   ~~~

   나는 실제로 이렇게 구현했다.

   ~~~js
   transitionEnd({
       firstContentPositionX,
       lastContentPositionX,
       minPositionX,
       maxPositionX}){
       this.slideListEl.addEventListener('transitionend',()=>{
           if(this.currentPositionX === maxPositionX)
               this.resetToInitContent(lastContentPositionX);
           if(this.currentPositionX === minPositionX )
               this.resetToInitContent(firstContentPositionX);
           })
       }
   ~~~

   transition이 끝났을 때 콜백함수안의 조건이 만족을 한다면 함수를 해당 함수를 호출하는 방식으로 변경하였다.

   이렇게 변경하고 나니 코드를 읽으며 세부적인 동작을 확인하는 것이 아닌 조건을 만족할 때

    resetToInitContent라는 함수를 호출해 "초기컨텐츠로 리셋하는 함수구나" 이런 느낌을 전달하려고 노력했다.

2. 중복함수 제거

   ~~~js
   clickNextBtn({firstContentPositionX, minPositionX}){
   	const nextBtn = this.naviEl.children[1];
   	nextBtn.addEventListener('click', ()=>{
   		this.slideContent(this.minusPositionX.bind(this), this.positionValue());
   		if(this.currentPositionX ===minPositionX)
               this.resetToInitContent(firstContentPositionX);
       })
   }
   clickPreBtn({lastContentPositionX, maxPositionX}){
       const preBtn = this.naviEl.children[0];
       preBtn.addEventListener('click', ()=>{
           this.slideContent(this.plusPositionX.bind(this), this.positionValue());
           if(this.currentPositionX === maxPositionX)
               this.resetToInitContent(lastContentPositionX);
       })
   }
   ~~~

   이렇게 비슷한 코드가 두개가 있었다. 코드가 정말 많이 비슷했지만, 동작이 반대방향이고, 인자로 받는 데이터가 전혀 반대라 수정하는데 조금 어려움이 있었다. 

   하지만 리팩토링과정에서 transitionEnd라는 메서드를 추가하고 나니, resetToInitContent를 여기 두 메서드에서

   호출하지 않아도 되는 의도하지않았지만 운좋은 상황이 만들어졌다. 그러자 바로 보였다.

   ~~~js
   clickNaviBtn(positionValue){
           
       this.naviEl.addEventListener('click', ({target})=>{
           if(target.className === "slide-prev")
               this.slideContent(this.plusPositionX.bind(this), positionValue);
           if(target.className === "slide-next")
               this.slideContent(this.minusPositionX.bind(this), positionValue);
       })
   }
   ~~~

   이렇게 메서드를 하나로 통합하고 event-delegation을 이용해서 클래스네임에 따라 메서드호출인자를 다르게 줄 수 있었다



## 잘한점

1. 코드를 만족감있게 구현했다. 아직 다른 잘하신분들 코드를 보면 놀랍지만, 이 방식대로 짜면서 더 좋은 방법들을 도입하면 앞으로 자신감이 생길 것 같다.
2. 리팩토링하니 코드가 훨씬 마음에 들게 수정되서 기분좋다



## 반성할 점

1. 프로젝트 진행속도가 너무 느리다. 너무 집중력이 낮은 거 같다. 계획을 너무 지키지 않는다...

   집도착시에 많은 거 바라지않고 딱 throttling 구현하고 적용하고 자야겠다.



## 내일할 일 

1. STEP8 Scoll이벤트를 활용해서 페이지 up&down구현하기

우선 여기까지 빨리 구현하고 그다음을 생각하자